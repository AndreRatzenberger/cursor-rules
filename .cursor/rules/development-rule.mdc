---
description: Controls development workflow with task tracking and management
globs: 
alwaysApply: true
---
# Development Workflow Management

Rule for tracking, documenting, and managing development tasks throughout their lifecycle.

<rule>
name: development_workflow
filters:
  - type: event
    pattern: "task_start"
  - type: event
    pattern: "task_plan"
  - type: event
    pattern: "task_complete"
  - type: command
    pattern: "task"
  - type: event
    pattern: "user_request"
  - type: event 
    pattern: "implementation_complete"
  - type: file_change
    pattern: "*.cursor/specs/*.md"

actions:
  - type: execute
    conditions:
      - pattern: "task_start|task create"
    command: |
      # Generate task ID (format: TASK-YYYY-MM-DD-NN)
      TASK_DATE=$(date +%Y-%m-%d)
      TASK_COUNT=$(ls -1 .cursor/tasks/${TASK_DATE}* 2>/dev/null | wc -l)
      TASK_NUM=$(printf "%02d" $((TASK_COUNT + 1)))
      TASK_ID="TASK-${TASK_DATE}-${TASK_NUM}"
      
      # Format task header
      TASK_HEADER=$(echo "$TASK_DESCRIPTION" | tr -d '\n' | head -c 50)
      if [ ${#TASK_DESCRIPTION} -gt 50 ]; then
        TASK_HEADER="${TASK_HEADER}..."
      fi
      
      # Create task directory if it doesn't exist
      mkdir -p .cursor/tasks
      
      # Create the task file
      TASK_FILE=".cursor/tasks/${TASK_ID}_${TASK_HEADER// /_}.md"
      cat > "$TASK_FILE" << EOF
# ${TASK_HEADER}

## Description
${TASK_DESCRIPTION}

## Relevant Specifications
${TASK_SPECS:-"- [ ] To be determined"}

## Acceptance Criteria
- [ ] Unit tests pass
${TASK_CRITERIA:-""}

## Metadata
- **Task ID**: ${TASK_ID}
- **Start Date**: $(date +"%Y-%m-%d")
- **End Date**: TBD
- **State**: 📝 (Open)

## Learnings
*Information learned during implementation that may be valuable for future reference*

EOF
      
      # Update the task index
      mkdir -p .cursor
      TASKS_INDEX=".cursor/TASKS.md"
      
      # Create index file if it doesn't exist
      if [ ! -f "$TASKS_INDEX" ]; then
        cat > "$TASKS_INDEX" << EOF
# Task Index

| Task ID | Date | State | Description |
|---------|------|-------|-------------|
EOF
      fi
      
      # Add the new task to the index
      SHORT_DESC=$(echo "$TASK_DESCRIPTION" | tr -d '\n' | head -c 80)
      if [ ${#TASK_DESCRIPTION} -gt 80 ]; then
        SHORT_DESC="${SHORT_DESC}..."
      fi
      
      echo "| [${TASK_ID}](.cursor/tasks/${TASK_ID}_${TASK_HEADER// /_}.md) | $(date +"%Y-%m-%d") | 📝 | ${SHORT_DESC} |" >> "$TASKS_INDEX"
      
      echo "Task created: ${TASK_ID} - ${TASK_HEADER}"
      echo "Task file: ${TASK_FILE}"

  - type: execute
    conditions:
      - pattern: "task_complete|task done"
    command: |
      # Get the task ID from the command
      if [ -z "$TASK_ID" ]; then
        echo "Error: No task ID provided"
        exit 1
      fi
      
      # Find the task file
      TASK_FILE=$(find .cursor/tasks -name "${TASK_ID}*.md" -print -quit)
      if [ -z "$TASK_FILE" ]; then
        echo "Error: Task ${TASK_ID} not found"
        exit 1
      fi
      
      # Update the task file with completion info
      sed -i "s/- \*\*End Date\*\*: TBD/- \*\*End Date\*\*: $(date +"%Y-%m-%d")/g" "$TASK_FILE"
      sed -i "s/- \*\*State\*\*: 📝 (Open)/- \*\*State\*\*: ✅ (Done)/g" "$TASK_FILE"
      sed -i "s/- \*\*State\*\*: 🔄 (Active)/- \*\*State\*\*: ✅ (Done)/g" "$TASK_FILE"
      
      # Extract learnings
      LEARNINGS=$(sed -n '/## Learnings/,/##/p' "$TASK_FILE" | sed '1d;$d')
      
      # Save learnings if they exist
      if [ ! -z "$LEARNINGS" ] && [ "$LEARNINGS" != "*Information learned during implementation that may be valuable for future reference*" ]; then
        mkdir -p .cursor/learnings
        LEARNING_FILE=".cursor/learnings/${TASK_ID}.md"
        
        cat > "$LEARNING_FILE" << EOF
# Learnings from ${TASK_ID}

${LEARNINGS}

*Task completed on: $(date +"%Y-%m-%d")*
EOF
        echo "Learnings saved to: ${LEARNING_FILE}"
      fi
      
      # Update task index
      TASKS_INDEX=".cursor/TASKS.md"
      sed -i "s|${TASK_ID}.*|[${TASK_ID}](.cursor/tasks/${TASK_ID}_*.md) | $(date +"%Y-%m-%d") | ✅ | $(grep "^# " "$TASK_FILE" | sed 's/# //g') ||g" "$TASKS_INDEX"
      
      # Mark associated specs as done if they exist
      SPECS=$(sed -n '/## Relevant Specifications/,/##/p' "$TASK_FILE" | sed '1d;$d' | grep "\- \[" | sed 's/- \[ \]/- \[x\]/g')
      if [ ! -z "$SPECS" ]; then
        sed -i "/## Relevant Specifications/,/##/c\\## Relevant Specifications\\n${SPECS}\\n" "$TASK_FILE"
      fi
      
      echo "Task ${TASK_ID} marked as complete"

  - type: execute
    conditions:
      - pattern: "task_status|task list"
    command: |
      # List all tasks with their status
      echo "# Task Status"
      echo ""
      echo "| Task ID | State | Description | Start Date | End Date |"
      echo "|---------|-------|-------------|------------|----------|"
      
      for TASK_FILE in $(find .cursor/tasks -name "*.md" -type f | sort); do
        TASK_ID=$(basename "$TASK_FILE" | cut -d'_' -f1)
        TASK_HEADER=$(grep "^# " "$TASK_FILE" | sed 's/# //g')
        TASK_STATE=$(grep "\*\*State\*\*:" "$TASK_FILE" | sed 's/.*\*\*State\*\*: \(.*\)/\1/g')
        START_DATE=$(grep "\*\*Start Date\*\*:" "$TASK_FILE" | sed 's/.*\*\*Start Date\*\*: \(.*\)/\1/g')
        END_DATE=$(grep "\*\*End Date\*\*:" "$TASK_FILE" | sed 's/.*\*\*End Date\*\*: \(.*\)/\1/g')
        
        echo "| ${TASK_ID} | ${TASK_STATE} | ${TASK_HEADER} | ${START_DATE} | ${END_DATE} |"
      done

  - type: execute
    conditions:
      - pattern: "task_active|task start"
    command: |
      # Mark a task as active
      if [ -z "$TASK_ID" ]; then
        echo "Error: No task ID provided"
        exit 1
      fi
      
      # Find the task file
      TASK_FILE=$(find .cursor/tasks -name "${TASK_ID}*.md" -print -quit)
      if [ -z "$TASK_FILE" ]; then
        echo "Error: Task ${TASK_ID} not found"
        exit 1
      fi
      
      # Update the task file to mark it as active
      sed -i "s/- \*\*State\*\*: 📝 (Open)/- \*\*State\*\*: 🔄 (Active)/g" "$TASK_FILE"
      
      # Update task index
      TASKS_INDEX=".cursor/TASKS.md"
      TASK_HEADER=$(grep "^# " "$TASK_FILE" | sed 's/# //g')
      SHORT_DESC=$(grep -A 2 "^## Description" "$TASK_FILE" | tail -n 1 | head -c 80)
      if [ ${#SHORT_DESC} -gt 80 ]; then
        SHORT_DESC="${SHORT_DESC}..."
      fi
      
      sed -i "s|${TASK_ID}.*|[${TASK_ID}](.cursor/tasks/${TASK_ID}_*.md) | $(date +"%Y-%m-%d") | 🔄 | ${SHORT_DESC} ||g" "$TASKS_INDEX"
      
      echo "Task ${TASK_ID} marked as active"

  - type: react
    event: "user_request"
    conditions:
      - pattern: "implement|create|build|develop"
    action: |
      # Auto-create task when user requests implementation
      # Extract task description from user request
      TASK_DESCRIPTION=$(echo "$USER_REQUEST" | sed -e 's/^[Pp]lease //g' -e 's/^[Cc]an you //g' -e 's/^[Ii]mplement //g' -e 's/^[Cc]reate //g' -e 's/^[Bb]uild //g' -e 's/^[Dd]evelop //g')
      
      # Find related specs if mentioned
      SPEC_FILES=$(echo "$USER_REQUEST" | grep -o "specs/[a-zA-Z0-9_/.-]\+\.md" || echo "")
      if [ -n "$SPEC_FILES" ]; then
        TASK_SPECS=$(echo "$SPEC_FILES" | sed 's/^/- [ ] /g')
      else
        # Look for recently updated spec files if none mentioned explicitly
        RECENT_SPECS=$(find .cursor/specs -name "*.md" -type f -mtime -1 | head -3 | sed 's/^/- [ ] /g')
        if [ -n "$RECENT_SPECS" ]; then
          TASK_SPECS="$RECENT_SPECS"
        else
          TASK_SPECS="- [ ] To be determined"
        fi
      fi
      
      # Generate task ID
      TASK_DATE=$(date +%Y-%m-%d)
      TASK_COUNT=$(ls -1 .cursor/tasks/${TASK_DATE}* 2>/dev/null | wc -l)
      TASK_NUM=$(printf "%02d" $((TASK_COUNT + 1)))
      TASK_ID="TASK-${TASK_DATE}-${TASK_NUM}"
      
      # Format task header (truncate if needed)
      TASK_HEADER=$(echo "$TASK_DESCRIPTION" | tr -d '\n' | head -c 50)
      if [ ${#TASK_DESCRIPTION} -gt 50 ]; then
        TASK_HEADER="${TASK_HEADER}..."
      fi
      
      # Create task directory if it doesn't exist
      mkdir -p .cursor/tasks
      
      # Create the task file
      TASK_FILE=".cursor/tasks/${TASK_ID}_${TASK_HEADER// /_}.md"
      cat > "$TASK_FILE" << EOF
# ${TASK_HEADER}

## Description
${TASK_DESCRIPTION}

## Relevant Specifications
${TASK_SPECS}

## Acceptance Criteria
- [ ] Unit tests pass
- [ ] Implementation matches specifications

## Metadata
- **Task ID**: ${TASK_ID}
- **Start Date**: $(date +"%Y-%m-%d")
- **End Date**: TBD
- **State**: 🔄 (Active)

## Learnings
*Information learned during implementation that may be valuable for future reference*

EOF
      
      # Update the task index
      mkdir -p .cursor
      TASKS_INDEX=".cursor/TASKS.md"
      
      # Create index file if it doesn't exist
      if [ ! -f "$TASKS_INDEX" ]; then
        cat > "$TASKS_INDEX" << EOF
# Task Index

| Task ID | Date | State | Description |
|---|---|----|----|
EOF
      fi
      
      # Add the new task to the index
      SHORT_DESC=$(echo "$TASK_DESCRIPTION" | tr -d '\n' | head -c 80)
      if [ ${#TASK_DESCRIPTION} -gt 80 ]; then
        SHORT_DESC="${SHORT_DESC}..."
      fi
      
      echo "| [${TASK_ID}](.cursor/tasks/${TASK_ID}_${TASK_HEADER// /_}.md) | $(date +"%Y-%m-%d") | 🔄 | ${SHORT_DESC} |" >> "$TASKS_INDEX"
      
      echo "Task automatically created and activated: ${TASK_ID} - ${TASK_HEADER}"

  - type: react
    event: "implementation_complete"
    action: |
      # Auto-complete task when implementation is finished
      # Find the active task
      ACTIVE_TASK=$(grep -l "**State**: 🔄 (Active)" .cursor/tasks/*.md | head -1)
      if [ -n "$ACTIVE_TASK" ]; then
        TASK_ID=$(basename "$ACTIVE_TASK" | cut -d'_' -f1)
        
        # Update the task file with completion info
        sed -i "s/- \*\*End Date\*\*: TBD/- \*\*End Date\*\*: $(date +"%Y-%m-%d")/g" "$ACTIVE_TASK"
        sed -i "s/- \*\*State\*\*: 🔄 (Active)/- \*\*State\*\*: ✅ (Done)/g" "$ACTIVE_TASK"
        
        # Extract learnings
        LEARNINGS=$(sed -n '/## Learnings/,/##/p' "$ACTIVE_TASK" | sed '1d;$d')
        
        # Save learnings if they exist and aren't just the default text
        if [ ! -z "$LEARNINGS" ] && [ "$LEARNINGS" != "*Information learned during implementation that may be valuable for future reference*" ]; then
          mkdir -p .cursor/learnings
          LEARNING_FILE=".cursor/learnings/${TASK_ID}.md"
          
          cat > "$LEARNING_FILE" << EOF
# Learnings from ${TASK_ID}

${LEARNINGS}

*Task completed on: $(date +"%Y-%m-%d")*
EOF
          echo "Learnings automatically saved to: ${LEARNING_FILE}"
        fi
        
        # Update task index
        TASKS_INDEX=".cursor/TASKS.md"
        sed -i "s|${TASK_ID}.*|[${TASK_ID}](.cursor/tasks/${TASK_ID}_*.md) | $(date +"%Y-%m-%d") | ✅ | $(grep "^# " "$ACTIVE_TASK" | sed 's/# //g') ||g" "$TASKS_INDEX"
        
        # Mark associated specs as done if they exist
        SPECS=$(sed -n '/## Relevant Specifications/,/##/p' "$ACTIVE_TASK" | sed '1d;$d' | grep "\- \[" | sed 's/- \[ \]/- \[x\]/g')
        if [ ! -z "$SPECS" ]; then
          sed -i "/## Relevant Specifications/,/##/c\\## Relevant Specifications\\n${SPECS}\\n" "$ACTIVE_TASK"
        fi
        
        echo "Task ${TASK_ID} automatically marked as complete"
      fi

  - type: suggest
    message: |
      ### Automatic Task Management

      Tasks are now automatically managed based on your requests and implementation progress:

      When you:
      - Ask me to implement a feature → A task is automatically created and activated
      - Have a completed implementation with passing tests → The task is automatically marked as complete

      You can still view task status with:
      ```
      task list
      ```

      And you can request information about specific tasks:
      ```
      Tell me about task TASK-YYYY-MM-DD-NN
      ```

      Tasks are stored in `.cursor/tasks/` with detailed information including:
      - Description
      - Related specifications
      - Acceptance criteria
      - Start and end dates
      - State (📝 Open, 🔄 Active, ✅ Done)
      - Learnings

      The task index is maintained in `.cursor/TASKS.md` for easy reference.

examples:
  - input: |
      # Create a new task
      TASK_DESCRIPTION="Implement user authentication flow"
      TASK_SPECS="- [ ] specs/auth/login.md\n- [ ] specs/auth/registration.md"
      TASK_CRITERIA="- [ ] Authentication flow works with OAuth providers\n- [ ] User session persists across page reloads"
    output: "Task created: TASK-2023-10-15-01 - Implement user authentication flow"

  - input: |
      # Complete a task
      TASK_ID="TASK-2023-10-15-01"
    output: "Task TASK-2023-10-15-01 marked as complete"

  - input: |
      # Activate a task
      TASK_ID="TASK-2023-10-15-02"
    output: "Task TASK-2023-10-15-02 marked as active"

metadata:
  priority: high
  version: 1.0
</rule> 