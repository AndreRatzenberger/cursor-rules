---
description: Automatically commit changes made by CursorAI using conventional commits format
globs: 
alwaysApply: true
---

# Git Conventional Commits

Rule for automatically committing changes made by CursorAI using conventional commits format.

<rule>
name: conventional_commits
filters:
  - type: event
    pattern: "build_success"
  - type: event
    pattern: "test_success"
  - type: event
    pattern: "file_save"
  - type: file_change
    pattern: "*"

actions:
  - type: react
    conditions:
      - pattern: "file_change|file_save"
    action: |
      # Automatically commit changes using conventional commits format
      
      When a file is changed or saved, I'll:
      1. Determine the appropriate commit type based on the change:
         - `feat`: For new features or functionality
         - `fix`: For bug fixes
         - `docs`: For documentation changes (including specs)
         - `style`: For formatting changes that don't affect code
         - `refactor`: For code restructuring without feature changes
         - `perf`: For performance improvements
         - `test`: For adding or correcting tests
         - `chore`: For maintenance tasks and build changes

      2. Extract scope from the file path (directory structure)
      
      3. Create a commit message in the format: `type(scope): description`
      
      4. For spec files, I'll use the format: `docs(specs): update specifications for <component>`

  - type: react
    event: "build_success"
    action: |
      # When a build succeeds, commit the changes
      
      After a successful build, I'll:
      1. Add all changed files to git staging
      2. Create an appropriate conventional commit message
      3. Commit the changes
      
      This ensures all successful builds are properly committed

  - type: react
    event: "test_success"
    action: |
      # When tests pass, commit the changes
      
      After successful tests, I'll:
      1. Add all changed files to git staging
      2. Create a conventional commit message, usually with `test` or `fix` type
      3. Commit the changes
      
      This ensures test-verified changes are committed

  - type: react
    event: "test_failure"
    action: |
      # When tests fail, don't commit and notify about test failures
      
      If tests fail, I'll:
      1. Not commit the changes
      2. Notify you about the failing tests
      3. Offer to help fix the failing tests
      
      This prevents committing code that doesn't pass tests

  - type: suggest
    message: |
      ### Conventional Commits System

      Changes are automatically committed using conventional commits format:

      **Format:** `type(scope): description`

      **Types:**
      - `feat`: A new feature
      - `fix`: A bug fix
      - `docs`: Documentation changes
      - `style`: Formatting changes (no code change)
      - `refactor`: Code restructuring (no feature change)
      - `perf`: Performance improvements
      - `test`: Test additions or corrections
      - `chore`: Maintenance tasks and build changes

      **Automatic Behaviors:**
      - After successful builds, changes are committed
      - After passing tests, changes are committed
      - Files in `.cursor/specs/` are committed as `docs(specs)`
      - Test failures prevent commits until fixed

      This ensures your repository maintains a clean, descriptive history that follows best practices.

examples:
  - input: |
      # After adding a new function
      feat(auth): add user authentication function
    output: "Changes committed with message: feat(auth): add user authentication function"

  - input: |
      # After updating a spec file
      docs(specs): update specifications for authentication
    output: "Spec changes committed with message: docs(specs): update specifications for authentication"

  - input: |
      # After fixing a bug
      fix(validation): correct email validation regex
    output: "Bug fix committed with message: fix(validation): correct email validation regex"

metadata:
  priority: high
  version: 1.0
</rule>
